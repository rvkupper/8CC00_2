%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{8CC00\_clusteringAndClassification}
\date{Apr 17, 2021}
\release{}
\author{Rebecca Kuepper}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Source Files}
\label{\detokenize{modules:source-files}}\label{\detokenize{modules::doc}}

\section{Clustering module}
\label{\detokenize{clustering:module-clustering}}\label{\detokenize{clustering:clustering-module}}\label{\detokenize{clustering::doc}}\index{module@\spxentry{module}!clustering@\spxentry{clustering}}\index{clustering@\spxentry{clustering}!module@\spxentry{module}}
\sphinxAtStartPar
Python scipt for clustering of data by means of k\sphinxhyphen{}means, evaluation with silhouette scores and HCS clustering.
\index{HCS() (in module clustering)@\spxentry{HCS()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.HCS}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{HCS}}}{\emph{\DUrole{n}{graph}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{originalEdges}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{nrIt}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{10}}, \emph{\DUrole{n}{clusters}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
\sphinxAtStartPar
Highly connected subgraph clustering.

\end{fulllineitems}

\index{calculateCentroids() (in module clustering)@\spxentry{calculateCentroids()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.calculateCentroids}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{calculateCentroids}}}{\emph{\DUrole{n}{clusteredData}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{dim}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ list}}
\sphinxAtStartPar
Recalculate the new centroid based on the averages in the old cluster configuration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dim}} \textendash{} required dimensions for the centroids.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List containing new centroids on the position of the average of the cluster.

\end{description}\end{quote}

\end{fulllineitems}

\index{contractEdge() (in module clustering)@\spxentry{contractEdge()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.contractEdge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{contractEdge}}}{\emph{\DUrole{n}{graph}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{v}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{w}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
.

\end{fulllineitems}

\index{createEdges() (in module clustering)@\spxentry{createEdges()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.createEdges}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{createEdges}}}{\emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{edgesdict}\DUrole{p}{:} \DUrole{n}{dict}}}{{ $\rightarrow$ list}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} threshold value for correlation coefficient of edge

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{edgesdict}} \textendash{} dictionary containing all possible edges and their correlation coefficients.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List like {[}(node1, node2), (node1, node3){]} where nodes are strings.

\end{description}\end{quote}

\end{fulllineitems}

\index{highlyConnected() (in module clustering)@\spxentry{highlyConnected()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.highlyConnected}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{highlyConnected}}}{\emph{\DUrole{n}{graph}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{mincut}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Decide whether graph is highly connected.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
minimumcut \textgreater{} nrNodes/2

\end{description}\end{quote}

\end{fulllineitems}

\index{kMeans() (in module clustering)@\spxentry{kMeans()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.kMeans}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{kMeans}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{k}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{distMethod}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{maxit}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ list}}
\sphinxAtStartPar
k\sphinxhyphen{}means algorithm, using the distMethod to calculate the distance between data points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} list of int, float, list or tuple values for datapoints.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} integer to decide the number of centroids.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{distMethod}} \textendash{} Method by which the distance between data points needs to be chosen.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{maxit}} \textendash{} Maximum number of iterations

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a list of sets per cluster.

\end{description}\end{quote}

\end{fulllineitems}

\index{karger2subgraph() (in module clustering)@\spxentry{karger2subgraph()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.karger2subgraph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{karger2subgraph}}}{\emph{\DUrole{n}{supernodesgraph}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{originalEdges}\DUrole{p}{:} \DUrole{n}{list}}}{}
\sphinxAtStartPar
Create subgraphs from the resulting supernodes graph after kargercut.

\end{fulllineitems}

\index{kargerMinCut() (in module clustering)@\spxentry{kargerMinCut()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.kargerMinCut}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{kargerMinCut}}}{\emph{\DUrole{n}{g}\DUrole{p}{:} \DUrole{n}{dict}}}{{ $\rightarrow$ tuple}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
minimum nr of edges that need to be cut, graph that remains

\end{description}\end{quote}

\end{fulllineitems}

\index{nodepairFraction() (in module clustering)@\spxentry{nodepairFraction()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.nodepairFraction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{nodepairFraction}}}{\emph{\DUrole{n}{overallCorrelations}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{c}\DUrole{p}{:} \DUrole{n}{float}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the fraction of node pairs that have an absolute value of their correlation coefficient of at least c.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{overallCorrelations}} \textendash{} dictionary containing node pairs and their correlations (can be calculated with the function overallCorrelationcoefficients)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} \textendash{} Threshold for fraction.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
fraction of number of node pairs that is above threshold.

\end{description}\end{quote}

\end{fulllineitems}

\index{overallCorrelationcoefficients() (in module clustering)@\spxentry{overallCorrelationcoefficients()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.overallCorrelationcoefficients}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{overallCorrelationcoefficients}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{names}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ dict}}
\sphinxAtStartPar
Create a dict in which for each node pair the correlation coefficient is calculated.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Dict like \{(node1, node2): correlationcoefficient\} where the nodes are strings and the correlation coefficient is a float.

\end{description}\end{quote}

\end{fulllineitems}

\index{silhouetteScore() (in module clustering)@\spxentry{silhouetteScore()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.silhouetteScore}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{silhouetteScore}}}{\emph{\DUrole{n}{clusteredData}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ tuple}}
\sphinxAtStartPar
Calculate silhouette score for clustered data.     Function returns tuple containing on the first index     the silhouette score for the clustering and in the     second index a dict containing the silhouettes for all     datapoints.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clusteredData}} \textendash{} list containing sets of data per cluster

\item[{Returns}] \leavevmode
\sphinxAtStartPar
(float, dict) where the float is the overall silhouette score for the clustering and the dict contains the silhouette per datapoint like \{(coordinate): silhouette\}

\item[{Examples}] \leavevmode
\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{5.5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mf}{5.5}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mf}{4.5}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{silhouetteScore}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
\PYG{g+go}{0.9352832294102621 \PYGZob{}(1.0, 1.5): 0.8928571428571429, (0.5, 0.5): 0.924812030075188, (1.5, 0.5): 0.8567493112947658, (0.5, 2.0): 0.8986666666666667, (6, 6): 0.9884169884169884, (6, 5.5): 0.9858490566037735, (5.5, 6): 0.9873949579831933, (4.5, 2.0): 0.9482758620689655, (3.5, 1.5): 0.9147540983606557, (4.0, 2.0): 0.9550561797752809\PYGZcb{}}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{squaredEuclideanDist() (in module clustering)@\spxentry{squaredEuclideanDist()}\spxextra{in module clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{clustering:clustering.squaredEuclideanDist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{clustering.}}\sphinxbfcode{\sphinxupquote{squaredEuclideanDist}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the Euclidean squared distance between u and v.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{u}} \textendash{} 1D or ND coordinate in int or float, or list or tuple respecitvely.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} \textendash{} 1D or ND coordinate in int or float, or list or tuple respecitvely.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
float of Euclidean squared distance between u and v.

\end{description}\end{quote}

\end{fulllineitems}



\section{Classification module}
\label{\detokenize{classification:module-classification}}\label{\detokenize{classification:classification-module}}\label{\detokenize{classification::doc}}\index{module@\spxentry{module}!classification@\spxentry{classification}}\index{classification@\spxentry{classification}!module@\spxentry{module}}
\sphinxAtStartPar
Script for classification assignment
\index{checkLabel() (in module classification)@\spxentry{checkLabel()}\spxextra{in module classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classification:classification.checkLabel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{classification.}}\sphinxbfcode{\sphinxupquote{checkLabel}}}{\emph{\DUrole{n}{datapointname}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{labelsdict}\DUrole{p}{:} \DUrole{n}{dict}}}{{ $\rightarrow$ bool}}
\sphinxAtStartPar
Checks if assigned label to datapoint is correct according to the information in the labelsdict.
:param datapoint: The point to be checked.
:param label: The label to be checked
:param labelsdict: The dict in which all labels for all datapoints are stored
:returns: True if label is correct, False if incorrect.

\end{fulllineitems}

\index{findName() (in module classification)@\spxentry{findName()}\spxextra{in module classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classification:classification.findName}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{classification.}}\sphinxbfcode{\sphinxupquote{findName}}}{\emph{\DUrole{n}{point}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{names}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ str}}
\sphinxAtStartPar
Find name that belongs to a datapoint. Note that data and names indices should match.

\end{fulllineitems}

\index{generateTrainingset() (in module classification)@\spxentry{generateTrainingset()}\spxextra{in module classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classification:classification.generateTrainingset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{classification.}}\sphinxbfcode{\sphinxupquote{generateTrainingset}}}{\emph{\DUrole{n}{fulldataset}\DUrole{p}{:} \DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{i}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{names}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ tuple}}
\sphinxAtStartPar
Generate a leave\sphinxhyphen{}one\sphinxhyphen{}out trainingsset at index i and return both.
:param fulldataset: the full dataset to be used 
:param i: the index of the point to be left out 
:param names: list of names for the datapoints
:returns: tuple containing trainingset, trainingnames, (new point name, new point coordinate)

\end{fulllineitems}

\index{nearestNeighbour() (in module classification)@\spxentry{nearestNeighbour()}\spxextra{in module classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{classification:classification.nearestNeighbour}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{classification.}}\sphinxbfcode{\sphinxupquote{nearestNeighbour}}}{\emph{\DUrole{n}{trainingset}\DUrole{p}{:} \DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{newDataPoint}}, \emph{\DUrole{n}{k}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{trainingnames}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{labelsdict}\DUrole{p}{:} \DUrole{n}{dict}}, \emph{\DUrole{n}{distMethod}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}sqEucl\textquotesingle{}}}}{{ $\rightarrow$ str}}
\sphinxAtStartPar
Nearest neighbour algorithm for classification of data.
:returns: label for new datapoint

\end{fulllineitems}



\section{Data extraction, transformation and loading module}
\label{\detokenize{dataETL:module-dataETL}}\label{\detokenize{dataETL:data-extraction-transformation-and-loading-module}}\label{\detokenize{dataETL::doc}}\index{module@\spxentry{module}!dataETL@\spxentry{dataETL}}\index{dataETL@\spxentry{dataETL}!module@\spxentry{module}}
\sphinxAtStartPar
Extraction, transformation and loading of data.
\index{extractData() (in module dataETL)@\spxentry{extractData()}\spxextra{in module dataETL}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dataETL:dataETL.extractData}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dataETL.}}\sphinxbfcode{\sphinxupquote{extractData}}}{\emph{\DUrole{n}{filename}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ tuple}}
\sphinxAtStartPar
Extract data from file.

\end{fulllineitems}

\index{extractLabels() (in module dataETL)@\spxentry{extractLabels()}\spxextra{in module dataETL}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dataETL:dataETL.extractLabels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dataETL.}}\sphinxbfcode{\sphinxupquote{extractLabels}}}{\emph{\DUrole{n}{file}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ list}}
\sphinxAtStartPar
Extract labels from csv file where names are in 2nd column and labels in the 4th.

\end{fulllineitems}

\index{selectData() (in module dataETL)@\spxentry{selectData()}\spxextra{in module dataETL}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dataETL:dataETL.selectData}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dataETL.}}\sphinxbfcode{\sphinxupquote{selectData}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ list}}
\sphinxAtStartPar
Select the desired data.

\end{fulllineitems}



\section{Data processing module}
\label{\detokenize{dataProcessing:module-dataProcessing}}\label{\detokenize{dataProcessing:data-processing-module}}\label{\detokenize{dataProcessing::doc}}\index{module@\spxentry{module}!dataProcessing@\spxentry{dataProcessing}}\index{dataProcessing@\spxentry{dataProcessing}!module@\spxentry{module}}
\sphinxAtStartPar
Some functions for the processing of data.
\index{correlationCoefficient() (in module dataProcessing)@\spxentry{correlationCoefficient()}\spxextra{in module dataProcessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dataProcessing:dataProcessing.correlationCoefficient}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dataProcessing.}}\sphinxbfcode{\sphinxupquote{correlationCoefficient}}}{\emph{\DUrole{n}{param1}\DUrole{p}{:} \DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{param2}\DUrole{p}{:} \DUrole{n}{collections.abc.Iterable}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the Pearson correlation coefficient of two parameters.
\begin{quote}\begin{description}
\item[{Examples}] \leavevmode
\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{correlationCoefficient}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.11}\PYG{p}{,} \PYG{l+m+mf}{0.12}\PYG{p}{,} \PYG{l+m+mf}{0.13}\PYG{p}{,} \PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{l+m+mf}{0.18}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{1.0}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{covariance() (in module dataProcessing)@\spxentry{covariance()}\spxextra{in module dataProcessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dataProcessing:dataProcessing.covariance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dataProcessing.}}\sphinxbfcode{\sphinxupquote{covariance}}}{\emph{\DUrole{n}{param1}\DUrole{p}{:} \DUrole{n}{list}}, \emph{\DUrole{n}{param2}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Return the covariance of parameter lists param1 and param2.

\sphinxAtStartPar
Assumption: param1 and param2 contain numbers and are of equal length.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param1}} \textendash{} List of parameters to be compared.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param2}} \textendash{} List of parameters to compare with.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
covariance of param1 and param2.

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{covariance}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{78}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{106.4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{covariance}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{g+gr}{AssertionError}: \PYG{n}{Parameter lists must be of the same length.    }
\end{sphinxVerbatim}

\end{fulllineitems}

\index{standardDeviation() (in module dataProcessing)@\spxentry{standardDeviation()}\spxextra{in module dataProcessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{dataProcessing:dataProcessing.standardDeviation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{dataProcessing.}}\sphinxbfcode{\sphinxupquote{standardDeviation}}}{\emph{\DUrole{n}{param}\DUrole{p}{:} \DUrole{n}{list}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Calculate the standard deviation of a list of measurements.
\begin{quote}\begin{description}
\item[{Examples}] \leavevmode
\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{standardDeviation}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{2.0}
\end{sphinxVerbatim}

\end{fulllineitems}



\section{Graph module}
\label{\detokenize{Graph:module-Graph}}\label{\detokenize{Graph:graph-module}}\label{\detokenize{Graph::doc}}\index{module@\spxentry{module}!Graph@\spxentry{Graph}}\index{Graph@\spxentry{Graph}!module@\spxentry{module}}
\sphinxAtStartPar
Script for Graphs
\index{Graph (class in Graph)@\spxentry{Graph}\spxextra{class in Graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Graph:Graph.Graph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Graph.}}\sphinxbfcode{\sphinxupquote{Graph}}}{\emph{\DUrole{n}{edges}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}
\index{removeEdge() (Graph.Graph method)@\spxentry{removeEdge()}\spxextra{Graph.Graph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Graph:Graph.Graph.removeEdge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{removeEdge}}}{\emph{\DUrole{n}{node1}}, \emph{\DUrole{n}{node2}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Remove edge between node 1 and node 2 from Graph.

\end{fulllineitems}

\index{removeNode() (Graph.Graph method)@\spxentry{removeNode()}\spxextra{Graph.Graph method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Graph:Graph.Graph.removeNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{removeNode}}}{\emph{\DUrole{n}{node}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Remove node from Graph.

\end{fulllineitems}


\end{fulllineitems}



\section{main module}
\label{\detokenize{main:module-main}}\label{\detokenize{main:main-module}}\label{\detokenize{main::doc}}\index{module@\spxentry{module}!main@\spxentry{main}}\index{main@\spxentry{main}!module@\spxentry{module}}
\sphinxAtStartPar
Main file for clustering and classification assignment.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{classification}\sphinxstyleindexpageref{classification:\detokenize{module-classification}}
\item\relax\sphinxstyleindexentry{clustering}\sphinxstyleindexpageref{clustering:\detokenize{module-clustering}}
\indexspace
\bigletter{d}
\item\relax\sphinxstyleindexentry{dataETL}\sphinxstyleindexpageref{dataETL:\detokenize{module-dataETL}}
\item\relax\sphinxstyleindexentry{dataProcessing}\sphinxstyleindexpageref{dataProcessing:\detokenize{module-dataProcessing}}
\indexspace
\bigletter{g}
\item\relax\sphinxstyleindexentry{Graph}\sphinxstyleindexpageref{Graph:\detokenize{module-Graph}}
\indexspace
\bigletter{m}
\item\relax\sphinxstyleindexentry{main}\sphinxstyleindexpageref{main:\detokenize{module-main}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}